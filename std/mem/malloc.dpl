#include <../exception.dpl>
#include <../io/print.dpl>

struct block_meta {
	// Metadata for a block of memory allocated by malloc
	// This is used to keep track of the size of the block and to allow free to work correctly
	size: int;			// Size of the block in bytes
	next: block_meta;	// Pointer to the next block in the linked list
	free: bool;			// Whether the block is free or not
}

fn get_current_break(): int {
    // Get the current break point of the heap as an integer
    // This is the address of the end of the heap, where new memory can be allocated

    asm "mov rax, 12	; syscall: sys_brk
    mov rdi, 0	; get current break
    syscall": int;
}

fn sbrk(dwords: int): array[int] {
	// sbrk, or sys_brk, is a syscall used to allocate memory in the heap
	// sys_brk(0) returns the current top of the heap, and sys_brk(size)
    // allocates bytes and returns the new top of the heap.

    // dwords is the number of double words (1 dword = 8 bytes) to allocate

    // When allocating blocks, they are surrounded by metadata which goes
    // [free flag (8 bytes)]    <- Highest address
    // [previous break point (8 bytes)] <- is 0 if this is the first block
    // [length of the block (8 bytes)]
    // [block (len of block bytes)]
    // [length of the block (8 bytes)]

    // Length of the block needs to be at the beginning so that arr.len works as expected,
    // but also at the end otherwise you can't know how long the first block is
    // since the previous break point is 0.

	if (dwords <= 0) {
		exception("sbrk: size must be at least 1", 1);
	}

    asm "	; Get current break point first
    mov rax, 12	; syscall: sys_brk  
    mov rdi, 0	; get current break
    syscall
    mov rbx, rax	; save old break in rbx";

    dwords * 8; // Convert dwords to bytes
    asm"    ; Now allocate new memory
    mov rdi, rbx    ; rbx contains the old break point
    add rdi, rax	; add size to the old break point
    add rdi, 32	; add 32 bytes for metadata
    mov rax, 12	; syscall: sys_brk
    syscall

    ; rbx now contains the start of our allocated block, and rax contains the new break point
    mov [rax - 16], rbx	; previous break point is stored at rax - 16
    mov dword [rax - 8], 1	; mark the block as not free (1 = not free, 0 = free)
    push rax    ; save the new break point on the stack";

    dwords;   // Move size into rax
    asm "	pop rcx     ; restore the new break point from the stack
    mov [rcx - 24], rax	; store the size of the block at rax - 24
    mov [rbx], rax	; store array length at start of block
    mov rax, rbx	; return the pointer
    add rax, 8	; move past the metadata": array[int];
}

fn malloc_call_count(): int {
    // Return the number of times malloc has been called
    asm "mov rax, [malloc_counter]": int; // Load the value of malloc_counter
}

fn malloc(size: int): array[int] {
    // let breakpoint: int = get_current_break();
    let malloc_used: int = malloc_call_count();
    asm "   add rax, 1
    mov [malloc_counter], rax"; // Add 1 to the malloc counter

    let ptr: array[int];

    // If this is the first malloc call, we need to set the next pointer to null
    if (malloc_used == 0) { // TODO: change this to (malloc_used == 0) when i figure out why it segfaults
        ptr = sbrk(size);
        ptr[ptr.len + 1] = 0; // Set the next pointer to null
    } else {
        // If malloc has been used, we need to find the next free block
        let current: int = get_current_break(); // Get the current break point
        let found: bool = false;

        while (current != 0 && !found) {
            if ((current: array[int])[-1] == 0) { // Check if the block is free
                if (((current: array[int])[-2] : array[int])[0] >= size) {    // Check if the block is large enough
                    found = true;
                }
                0;
            } else {
                current = (current: array[int])[-2]; // Move to the next block
            }
        }

        if (!found) {
            ptr = sbrk(size); // Allocate a new block if no free block was found
            0;
        } else {
            ptr = current: array[int]; // Use the found free block
            ptr[ptr.len + 2] = 1; // Mark the block as used
        }
    }

	return ptr;
}

fn free(ptr: array[int]): int {
    // Free a block of memory allocated by malloc
    // This will mark the block as free and add it to the linked list of free blocks

    if (ptr.len <= 0) {
        exception("free: pointer must be valid", 1);
    }

    let size: int = ptr.len; // Get the size of the block
    ptr[ptr.len + 2] = 0; // Flag the block as free
}

fn calloc(size: int): array[int] {
    // calloc allocates memory and initializes it to zero
    let ptr: array[int] = malloc(size);
    arrset:<int>(ptr, 0); // Set all elements to zero
    return ptr;
}

fn realloc(ptr: array[int], new_size: int): array[int] {
    if (new_size <= 0) {
        exception("realloc: new size must be at least 1", 1);
    }

    let old_size: int = ptr.len;
    let new_ptr: array[int] = malloc(new_size);

    // Copy old data to new pointer
    for (let i: int = 0; i < old_size && i < new_size; i += 1) {
        new_ptr[i] = ptr[i];
    }

    free(ptr); // Free the old pointer
    return new_ptr;
}

fn arrset:<T>(arr: array[T], value: T): T {
    for (let i: int = 0; i < arr.len; i += 1) {
        arr[i] = value;
    }
}

fn memset(ptr: array[int], value: int, size: int): int {
    // Very similar to arrset, but ignores the length of the array,
    // letting the user set arbitrary chinks of memory as long as they have
    // a pointer to them.
    if (size < 0) {
        exception("memset: size must be a positive number", 1);
    }

    for (let i: int = 0; i < size; i += 1) {
        ptr[i] = value;
    }
}

fn print_heap_layout(): int {
    let current: int = get_current_break(); // Get the current break point
    let counter: int = 0;

    println("Free flag (0=free), len");

    while (current != 0) {
        printi((current: array[int])[-1]);
        print(", ");
        printiln((current: array[int])[-3]);
        current = (current: array[int])[-2]; // Move to the next block
        // printiln((current: array[int])[0]);
        counter += 1;
    }

    print("Malloc has been called ");
    printi(malloc_call_count());
    println(" times.");
    print("There are ");
    printi(counter);
    println(" blocks in total");
}